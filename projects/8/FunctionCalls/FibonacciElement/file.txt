
//0 @256
//1 D=A
//2 @0
//3 M=D
//[1] push return_address
//4 @53
//5 D=A
//6 @0
//7 A=M
//8 M=D
//9 @0
//10 M=M+1
//[2] push LCL
//11 @1
//12 D=M
//13 @0
//14 A=M
//15 M=D
//16 @0
//17 M=M+1
//[3] push ARG
//18 @2
//19 D=M
//20 @0
//21 A=M
//22 M=D
//23 @0
//24 M=M+1
//[4] push THIS
//25 @3
//26 D=M
//27 @0
//28 A=M
//29 M=D
//30 @0
//31 M=M+1
//[5] push THAT
//32 @4
//33 D=M
//34 @0
//35 A=M
//36 M=D
//37 @0
//38 M=M+1
//[6] ARG = sp - 5 -nArgs
//39 @5
//40 D=A
//41 @0
//42 D=M-D
//Not putting args
//43 @0
//44 D=D-A
//45 @2
//46 M=D
//[7] LCL = SP
//47 @0
//48 D=M
//49 @1
//50 M=D
//[8] goto f
//51 @Sys.init
//52 0;JMP
//[9]
(53)


//function Main.fibonacci 0

// Declare a label for the function entry
// that functionName is codeWritterObj->parser->getArg1()
(Main.fibonacci)
// k  number of local variables
// Initialize all of them to 0
// that k is codeWritterObj->parser->getArg2()
//53 @0
//54 D=A
//55 @13
//56 @SKIPMain.fibonacci
//57 D;JEQ
//58 M=D
(FPUSHMain.fibonacci)
//59 @0
//60 A=M
//61 M=0
//62 @0
//63 M=M+1
//64 @13
//65 M=M-1
//66 D=M
//67 @FPUSHMain.fibonacci
//68 D;JGT
(SKIPMain.fibonacci)
//instructions:	16
//push argument 0

//69 @0
//70 D=A
//71 @2
//72 A=D+M
//73 D=M
//74 @0
//75 A=M
//76 M=D
//77 @0
//78 M=M+1

//instructions:	10
//push constant 2

//79 @2
//80 D=A
//81 @0
//82 A=M
//83 M=D
//84 @0
//85 M=M+1

//instructions:	7// Setting to 0 last 2 values and then pointing to the n-1 value for putting the result in there

//lt

//86 @0
//87 M=M-1
//88 A=M
//89 D=M
//90 @0
//91 M=M-1
//92 A=M
//93 M=M-D
//94 D=M
//95 @FIRST0
//96 D;JLT
//97 D=0
//98 @CONTINUE0
//99 0;JMP
(FIRST0)
//100 D=-1
//101 @CONTINUE0
//102 0;JMP
(CONTINUE0)
//103 @0
//104 A=M
//105 M=D
//106 @0
//107 M=M+1

//instructions:	22
//if-goto N_LT_2

//108 @0
//109 M=M-1
//110 A=M
//111 D=M
//112 @N_LT_2
//113 D;JNE

//instructions:	6
//goto N_GE_2

//114 @N_GE_2
//115 0;JMP

//instructions:	2
//label N_LT_2               // if n < 2 returns n

(N_LT_2)

//instructions:	0
//push argument 0

//116 @0
//117 D=A
//118 @2
//119 A=D+M
//120 D=M
//121 @0
//122 A=M
//123 M=D
//124 @0
//125 M=M+1

//instructions:	10
//return

// FRAME = LCL
//126 @1
//127 D=M
//128 @13
//129 M=D
// RET = *(FRAME - 5)
//130 @13
//131 D=M
//132 @15
//133 M=D
//134 @5
//135 D=A
//136 @15
//137 M=M-D
//138 A=M
//139 D=M
//140 @14
//141 M=D
// *ARG = pop()
//142 @0
//143 M=M-1
//144 A=M
//145 D=M
//146 @2
//147 A=M
//148 M=D
// SP = ARG+1
//149 @1
//150 D=A
//151 @2
//152 D=M+D
//153 @0
//154 M=D
// THAT = *(FRAME-1)
//155 @13
//156 D=M
//157 @15
//158 M=D
//159 @1
//160 D=A
//161 @15
//162 M=M-D
//163 A=M
//164 D=M
//165 @4
//166 M=D
// THIS = *(FRAME - 2)
//167 @13
//168 D=M
//169 @15
//170 M=D
//171 @2
//172 D=A
//173 @15
//174 M=M-D
//175 A=M
//176 D=M
//177 @3
//178 M=D
// ARG = *(FRAME - 3)
//179 @13
//180 D=M
//181 @15
//182 M=D
//183 @3
//184 D=A
//185 @15
//186 M=M-D
//187 A=M
//188 D=M
//189 @2
//190 M=D
// LCL = *(FRAME - 4)
//191 @13
//192 D=M
//193 @15
//194 M=D
//195 @4
//196 D=A
//197 @15
//198 M=M-D
//199 A=M
//200 D=M
//201 @1
//202 M=D
//goto RET
//be carefull here to examine
// the idea is the following I need
//to go back to the location
//location is stored in RET
//203 @14
//204 A=M
//205 0;JMP

//instructions:	80
//label N_GE_2               // if n >= 2 returns fib(n - 2) + fib(n - 1)

(N_GE_2)

//instructions:	0
//push argument 0

//206 @0
//207 D=A
//208 @2
//209 A=D+M
//210 D=M
//211 @0
//212 A=M
//213 M=D
//214 @0
//215 M=M+1

//instructions:	10
//push constant 2

//216 @2
//217 D=A
//218 @0
//219 A=M
//220 M=D
//221 @0
//222 M=M+1

//instructions:	7// Setting to 0 last 2 values and then pointing to the n-1 value for putting the result in there

//sub

//223 @0
//224 M=M-1
//225 A=M
//226 D=M
//227 @0
//228 M=M-1
//229 A=M
//230 M=M-D
//231 @0
//232 M=M+1

//instructions:	10
//call Main.fibonacci 1  // computes fib(n - 2)

//[1] push return_address
//233 @282
//234 D=A
//235 @0
//236 A=M
//237 M=D
//238 @0
//239 M=M+1
//[2] push LCL
//240 @1
//241 D=M
//242 @0
//243 A=M
//244 M=D
//245 @0
//246 M=M+1
//[3] push ARG
//247 @2
//248 D=M
//249 @0
//250 A=M
//251 M=D
//252 @0
//253 M=M+1
//[4] push THIS
//254 @3
//255 D=M
//256 @0
//257 A=M
//258 M=D
//259 @0
//260 M=M+1
//[5] push THAT
//261 @4
//262 D=M
//263 @0
//264 A=M
//265 M=D
//266 @0
//267 M=M+1
//[6] ARG = sp - 5 -nArgs
//268 @5
//269 D=A
//270 @0
//271 D=M-D
//272 @1
//273 D=D-A
//274 @2
//275 M=D
//[7] LCL = SP
//276 @0
//277 D=M
//278 @1
//279 M=D
//[8] goto f
//280 @Main.fibonacci
//281 0;JMP
//[9]
(282)

//instructions:	49
//push argument 0

//282 @0
//283 D=A
//284 @2
//285 A=D+M
//286 D=M
//287 @0
//288 A=M
//289 M=D
//290 @0
//291 M=M+1

//instructions:	10
//push constant 1

//292 @1
//293 D=A
//294 @0
//295 A=M
//296 M=D
//297 @0
//298 M=M+1

//instructions:	7// Setting to 0 last 2 values and then pointing to the n-1 value for putting the result in there

//sub

//299 @0
//300 M=M-1
//301 A=M
//302 D=M
//303 @0
//304 M=M-1
//305 A=M
//306 M=M-D
//307 @0
//308 M=M+1

//instructions:	10
//call Main.fibonacci 1  // computes fib(n - 1)

//[1] push return_address
//309 @358
//310 D=A
//311 @0
//312 A=M
//313 M=D
//314 @0
//315 M=M+1
//[2] push LCL
//316 @1
//317 D=M
//318 @0
//319 A=M
//320 M=D
//321 @0
//322 M=M+1
//[3] push ARG
//323 @2
//324 D=M
//325 @0
//326 A=M
//327 M=D
//328 @0
//329 M=M+1
//[4] push THIS
//330 @3
//331 D=M
//332 @0
//333 A=M
//334 M=D
//335 @0
//336 M=M+1
//[5] push THAT
//337 @4
//338 D=M
//339 @0
//340 A=M
//341 M=D
//342 @0
//343 M=M+1
//[6] ARG = sp - 5 -nArgs
//344 @5
//345 D=A
//346 @0
//347 D=M-D
//348 @1
//349 D=D-A
//350 @2
//351 M=D
//[7] LCL = SP
//352 @0
//353 D=M
//354 @1
//355 M=D
//[8] goto f
//356 @Main.fibonacci
//357 0;JMP
//[9]
(358)

//instructions:	49// Setting to 0 last 2 values and then pointing to the n-1 value for putting the result in there

//add                    // returns fib(n - 1) + fib(n - 2)

//358 @0
//359 M=M-1
//360 A=M
//361 D=M
//362 @0
//363 M=M-1
//364 A=M
//365 M=M+D
//366 @0
//367 M=M+1

//instructions:	10
//return

// FRAME = LCL
//368 @1
//369 D=M
//370 @13
//371 M=D
// RET = *(FRAME - 5)
//372 @13
//373 D=M
//374 @15
//375 M=D
//376 @5
//377 D=A
//378 @15
//379 M=M-D
//380 A=M
//381 D=M
//382 @14
//383 M=D
// *ARG = pop()
//384 @0
//385 M=M-1
//386 A=M
//387 D=M
//388 @2
//389 A=M
//390 M=D
// SP = ARG+1
//391 @1
//392 D=A
//393 @2
//394 D=M+D
//395 @0
//396 M=D
// THAT = *(FRAME-1)
//397 @13
//398 D=M
//399 @15
//400 M=D
//401 @1
//402 D=A
//403 @15
//404 M=M-D
//405 A=M
//406 D=M
//407 @4
//408 M=D
// THIS = *(FRAME - 2)
//409 @13
//410 D=M
//411 @15
//412 M=D
//413 @2
//414 D=A
//415 @15
//416 M=M-D
//417 A=M
//418 D=M
//419 @3
//420 M=D
// ARG = *(FRAME - 3)
//421 @13
//422 D=M
//423 @15
//424 M=D
//425 @3
//426 D=A
//427 @15
//428 M=M-D
//429 A=M
//430 D=M
//431 @2
//432 M=D
// LCL = *(FRAME - 4)
//433 @13
//434 D=M
//435 @15
//436 M=D
//437 @4
//438 D=A
//439 @15
//440 M=M-D
//441 A=M
//442 D=M
//443 @1
//444 M=D
//goto RET
//be carefull here to examine
// the idea is the following I need
//to go back to the location
//location is stored in RET
//445 @14
//446 A=M
//447 0;JMP

//instructions:	80// TOTAL LINES:448
//END OF FILE

//function Sys.init 0

// Declare a label for the function entry
// that functionName is codeWritterObj->parser->getArg1()
(Sys.init)
// k  number of local variables
// Initialize all of them to 0
// that k is codeWritterObj->parser->getArg2()
//448 @0
//449 D=A
//450 @13
//451 @SKIPSys.init
//452 D;JEQ
//453 M=D
(FPUSHSys.init)
//454 @0
//455 A=M
//456 M=0
//457 @0
//458 M=M+1
//459 @13
//460 M=M-1
//461 D=M
//462 @FPUSHSys.init
//463 D;JGT
(SKIPSys.init)
//instructions:	16
//push constant 4

//464 @4
//465 D=A
//466 @0
//467 A=M
//468 M=D
//469 @0
//470 M=M+1

//instructions:	7
//call Main.fibonacci 1

//[1] push return_address
//471 @520
//472 D=A
//473 @0
//474 A=M
//475 M=D
//476 @0
//477 M=M+1
//[2] push LCL
//478 @1
//479 D=M
//480 @0
//481 A=M
//482 M=D
//483 @0
//484 M=M+1
//[3] push ARG
//485 @2
//486 D=M
//487 @0
//488 A=M
//489 M=D
//490 @0
//491 M=M+1
//[4] push THIS
//492 @3
//493 D=M
//494 @0
//495 A=M
//496 M=D
//497 @0
//498 M=M+1
//[5] push THAT
//499 @4
//500 D=M
//501 @0
//502 A=M
//503 M=D
//504 @0
//505 M=M+1
//[6] ARG = sp - 5 -nArgs
//506 @5
//507 D=A
//508 @0
//509 D=M-D
//510 @1
//511 D=D-A
//512 @2
//513 M=D
//[7] LCL = SP
//514 @0
//515 D=M
//516 @1
//517 M=D
//[8] goto f
//518 @Main.fibonacci
//519 0;JMP
//[9]
(520)

//instructions:	49
//label END

(END)

//instructions:	0
//goto END  // loops infinitely

//520 @END
//521 0;JMP

//instructions:	2// TOTAL LINES:522
//END OF FILE
